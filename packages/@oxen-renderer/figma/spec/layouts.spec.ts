/**
 * @file Layout rendering tests
 * Tests Figma auto-layout and constraints rendering
 *
 * Test coverage:
 * - Auto Layout: stackMode, stackPrimaryAlignItems, stackCounterAlignItems, stackSpacing
 * - Constraints: horizontalConstraint, verticalConstraint
 * - INSTANCE node resolution: INSTANCE nodes referencing SYMBOL are resolved via symbolMap
 */

import * as fs from "node:fs";
import * as path from "node:path";
import { fileURLToPath } from "node:url";
import { parseFigFile, buildNodeTree, findNodesByType, getNodeType, type FigBlob, type FigImage } from "@oxen/fig/parser";
import type { FigNode } from "@oxen/fig/types";
import { renderCanvas } from "../src/svg/renderer";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const FIXTURES_DIR = path.join(__dirname, "../fixtures/layouts");
const ACTUAL_DIR = path.join(FIXTURES_DIR, "actual");
const FIG_FILE = path.join(FIXTURES_DIR, "layouts.fig");

/**
 * Mapping of layer names in .fig file to actual SVG filenames
 *
 * Test cases generated by: scripts/generate-layout-fixtures.ts
 */
/** Layer names matching autolayout.fig structure */
const LAYER_FILE_MAP: Record<string, string> = {
  "simple-rects": "simple-rects.svg",
  "auto-h-min": "auto-h-min.svg",
  "auto-h-center": "auto-h-center.svg",
  "auto-h-max": "auto-h-max.svg",
  "auto-v-min": "auto-v-min.svg",
  "auto-v-center": "auto-v-center.svg",
  "auto-v-max": "auto-v-max.svg",
  "auto-h-space-between": "auto-h-space-between.svg",
  "auto-gap-0": "auto-gap-0.svg",
  "auto-gap-20": "auto-gap-20.svg",
  "auto-padding-20": "auto-padding-20.svg",
  "constraints-corners": "constraints-corners.svg",
};

type LayerInfo = {
  name: string;
  node: FigNode;
  size: { width: number; height: number };
};

type ParsedData = {
  canvases: readonly FigNode[];
  layers: Map<string, LayerInfo>;
  blobs: readonly FigBlob[];
  images: ReadonlyMap<string, FigImage>;
  nodeMap: ReadonlyMap<string, FigNode>;
};

const parsedDataCache: { value: ParsedData | null } = { value: null };

/**
 * Load and parse the .fig file once
 */
async function loadFigFile(): Promise<ParsedData> {
  if (parsedDataCache.value) {
    return parsedDataCache.value;
  }

  const data = fs.readFileSync(FIG_FILE);
  const parsed = await parseFigFile(new Uint8Array(data));
  const { roots, nodeMap } = buildNodeTree(parsed.nodeChanges);

  const canvases = findNodesByType(roots, "CANVAS");

  const layers = new Map<string, LayerInfo>();

  // Search all canvases for matching layers
  for (const canvas of canvases) {
    for (const child of canvas.children ?? []) {
      const name = child.name ?? "unnamed";
      const nodeData = child as Record<string, unknown>;
      const size = nodeData.size as { x?: number; y?: number } | undefined;
      layers.set(name, {
        name,
        node: child,
        size: {
          width: size?.x ?? 100,
          height: size?.y ?? 100,
        },
      });
    }
  }

  parsedDataCache.value = { canvases, layers, blobs: parsed.blobs, images: parsed.images, nodeMap };
  return parsedDataCache.value;
}

/**
 * Get size from actual SVG content
 */
function getSizeFromSvg(content: string): { width: number; height: number } {
  const widthMatch = content.match(/width="(\d+)"/);
  const heightMatch = content.match(/height="(\d+)"/);
  return {
    width: widthMatch ? parseInt(widthMatch[1], 10) : 100,
    height: heightMatch ? parseInt(heightMatch[1], 10) : 100,
  };
}

/**
 * Extract statistics from SVG content for comparison
 */
function extractSvgStats(content: string): {
  elementCount: number;
  rectCount: number;
  fillColors: string[];
  clipPathCount: number;
  rectPositions: Array<{ x: number; y: number; width: number; height: number }>;
} {
  // Extract rect positions for layout comparison
  const rectRegex = /<rect[^>]*(?:x="(\d+(?:\.\d+)?)")?[^>]*(?:y="(\d+(?:\.\d+)?)")?[^>]*width="(\d+(?:\.\d+)?)"[^>]*height="(\d+(?:\.\d+)?)"/g;
  const rectPositions: Array<{ x: number; y: number; width: number; height: number }> = [];
  let match;
  while ((match = rectRegex.exec(content)) !== null) {
    rectPositions.push({
      x: parseFloat(match[1] ?? "0"),
      y: parseFloat(match[2] ?? "0"),
      width: parseFloat(match[3]),
      height: parseFloat(match[4]),
    });
  }

  return {
    elementCount: (content.match(/<(rect|ellipse|path|text|image|circle)/g) || []).length,
    rectCount: (content.match(/<rect/g) || []).length,
    fillColors: [...new Set((content.match(/fill="#[0-9a-fA-F]{6}"/g) || []).map((m) => m.slice(6, -1)))],
    clipPathCount: (content.match(/<clipPath/g) || []).length,
    rectPositions,
  };
}

/**
 * Whether to write rendered SVGs to the snapshots directory for visual inspection
 */
const WRITE_SNAPSHOTS = process.env.WRITE_SNAPSHOTS === "true";
const SNAPSHOTS_DIR = path.join(FIXTURES_DIR, "snapshots/rendered");

describe("SVG Renderer - Layout features", () => {
  beforeAll(async () => {
    await loadFigFile();
    if (WRITE_SNAPSHOTS && !fs.existsSync(SNAPSHOTS_DIR)) {
      fs.mkdirSync(SNAPSHOTS_DIR, { recursive: true });
    }
  });

  // Test each mapped layer
  for (const [layerName, fileName] of Object.entries(LAYER_FILE_MAP)) {
    it(`renders "${layerName}" with expected structure`, async () => {
      const data = await loadFigFile();
      const layer = data.layers.get(layerName);

      if (!layer) {
        console.log(`SKIP: Layer "${layerName}" not found in .fig file`);
        console.log(`  Available layers: ${[...data.layers.keys()].join(", ")}`);
        return;
      }

      const actualPath = path.join(ACTUAL_DIR, fileName);
      if (!fs.existsSync(actualPath)) {
        console.log(`SKIP: Actual SVG not found: ${fileName}`);
        return;
      }

      // Load actual SVG
      const actualContent = fs.readFileSync(actualPath, "utf-8");
      const actualSize = getSizeFromSvg(actualContent);
      const actualStats = extractSvgStats(actualContent);

      // Render the layer
      const wrapperCanvas: FigNode = {
        type: "CANVAS",
        name: layerName,
        children: [layer.node],
      };

      const result = renderCanvas(wrapperCanvas, {
        width: actualSize.width,
        height: actualSize.height,
        blobs: data.blobs,
        images: data.images,
        symbolMap: data.nodeMap,
      });
      const renderedStats = extractSvgStats(result.svg);

      // Write snapshot for visual inspection
      if (WRITE_SNAPSHOTS) {
        const snapshotPath = path.join(SNAPSHOTS_DIR, fileName);
        fs.writeFileSync(snapshotPath, result.svg);
      }

      // Output comparison info
      console.log(`\n--- ${layerName} ---`);
      console.log(`Size: ${actualSize.width}x${actualSize.height}`);
      console.log(`Rect count: rendered=${renderedStats.rectCount}, actual=${actualStats.rectCount}`);
      console.log(`Fill colors: rendered=${renderedStats.fillColors.join(", ")}, actual=${actualStats.fillColors.join(", ")}`);
      console.log(`ClipPaths: rendered=${renderedStats.clipPathCount}, actual=${actualStats.clipPathCount}`);

      if (result.warnings.length > 0) {
        console.log(`Warnings: ${result.warnings.slice(0, 3).join("; ")}${result.warnings.length > 3 ? `... (+${result.warnings.length - 3} more)` : ""}`);
      }

      // Basic sanity checks
      expect(result.svg).toContain("<svg");
      expect(result.svg).toContain("</svg>");

      // Check that we're producing some content
      expect(renderedStats.elementCount).toBeGreaterThan(0);
    });
  }
});

describe("SVG Renderer - Layout node type coverage", () => {
  it("reports node types in layouts.fig", async () => {
    const data = await loadFigFile();

    const nodeTypeCounts = new Map<string, number>();

    function countNodeTypes(nodes: readonly FigNode[]): void {
      for (const node of nodes) {
        const type = getNodeType(node);
        nodeTypeCounts.set(type, (nodeTypeCounts.get(type) ?? 0) + 1);
        if (node.children) {
          countNodeTypes(node.children);
        }
      }
    }

    for (const canvas of data.canvases) {
      countNodeTypes(canvas.children ?? []);
    }

    console.log("\n--- Node Type Distribution in layouts.fig ---");
    const sorted = [...nodeTypeCounts.entries()].sort((a, b) => b[1] - a[1]);
    for (const [type, count] of sorted) {
      console.log(`  ${type}: ${count}`);
    }

    // Verify we have nodes to render
    expect(nodeTypeCounts.size).toBeGreaterThan(0);
  });

  it("lists available layers in layouts.fig", async () => {
    const data = await loadFigFile();

    console.log("\n--- Available Layers in layouts.fig ---");
    for (const [name, info] of data.layers) {
      const nodeData = info.node as Record<string, unknown>;
      const type = getNodeType(info.node);
      console.log(`  "${name}" (${type}) - ${info.size.width}x${info.size.height}`);

      // Log layout-related properties if present
      const layoutMode = nodeData.derivedTextData ? "AUTO_LAYOUT" : nodeData.stackMode;
      if (layoutMode) {
        console.log(`    layoutMode: ${layoutMode}`);
      }
    }

    expect(data.layers.size).toBeGreaterThan(0);
  });
});

describe("SVG Renderer - Layer structure", () => {
  it("inspects layer structure", async () => {
    const data = await loadFigFile();

    console.log("\n--- Layer Structure ---");
    for (const [name, info] of data.layers) {
      const nodeType = getNodeType(info.node);
      console.log(`  "${name}" (${nodeType}) - ${info.size.width}x${info.size.height}`);
      console.log(`    children: ${info.node.children?.length ?? 0}`);
    }

    // Verify we have layers (FRAME or GROUP)
    expect(data.layers.size).toBeGreaterThan(0);
  });
});

describe("SVG Renderer - Layout-specific properties", () => {
  it("inspects layout properties of frames", async () => {
    const data = await loadFigFile();

    console.log("\n--- Layout Properties ---");
    for (const [name, info] of data.layers) {
      const nodeData = info.node as Record<string, unknown>;

      // Extract layout-related properties
      const layoutProps = {
        stackMode: nodeData.stackMode,
        stackPrimaryAlignItems: nodeData.stackPrimaryAlignItems,
        stackCounterAlignItems: nodeData.stackCounterAlignItems,
        stackPrimaryAlignContent: nodeData.stackPrimaryAlignContent,
        stackSpacing: nodeData.stackSpacing,
        stackPadding: nodeData.stackPadding,
        stackPaddingLeft: nodeData.stackPaddingLeft,
        stackPaddingRight: nodeData.stackPaddingRight,
        stackPaddingTop: nodeData.stackPaddingTop,
        stackPaddingBottom: nodeData.stackPaddingBottom,
        itemSpacing: nodeData.itemSpacing,
        horizontalConstraint: nodeData.horizontalConstraint,
        verticalConstraint: nodeData.verticalConstraint,
      };

      // Check if any layout properties exist
      const hasLayoutProps = Object.values(layoutProps).some((v) => v !== undefined);
      if (hasLayoutProps) {
        console.log(`\n  "${name}":`);
        for (const [key, value] of Object.entries(layoutProps)) {
          if (value !== undefined) {
            console.log(`    ${key}: ${JSON.stringify(value)}`);
          }
        }
      }

      // Also check children for constraints
      const children = info.node.children ?? [];
      for (const child of children) {
        const childData = child as Record<string, unknown>;
        const hConstraint = childData.horizontalConstraint;
        const vConstraint = childData.verticalConstraint;
        if (hConstraint !== undefined || vConstraint !== undefined) {
          console.log(`    child "${child.name}": h=${JSON.stringify(hConstraint)}, v=${JSON.stringify(vConstraint)}`);
        }
      }
    }

    expect(data.layers.size).toBeGreaterThan(0);
  });
});
