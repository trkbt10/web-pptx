/**
 * @file src/pdf/parser/clip-mask-apply.native.ts
 *
 * Applies per-pixel `graphicsState.clipMask` to `PdfImage` alpha.
 *
 * Notes:
 * - `clipMask` is stored in page space (its `/BBox` is page coordinates).
 * - `image.graphicsState.ctm` maps image-space unit square → page space.
 */

import type { PdfImage, PdfMatrix, PdfSoftMask } from "../../domain";
import { invertMatrix, transformPoint } from "../../domain";

function sampleMaskAlphaInPageSpace(mask: PdfSoftMask, x: number, y: number): number {
  const [llx, lly, urx, ury] = mask.bbox;
  const bw = urx - llx;
  const bh = ury - lly;
  if (!Number.isFinite(bw) || !Number.isFinite(bh) || bw <= 0 || bh <= 0) {return 0;}

  const nx = (x - llx) / bw;
  const ny = (ury - y) / bh; // top-down mapping
  if (!Number.isFinite(nx) || !Number.isFinite(ny)) {return 0;}
  if (nx < 0 || nx >= 1 || ny < 0 || ny >= 1) {return 0;}

  const col = Math.min(mask.width - 1, Math.max(0, Math.floor(nx * mask.width)));
  const row = Math.min(mask.height - 1, Math.max(0, Math.floor(ny * mask.height)));
  return mask.alpha[row * mask.width + col] ?? 0;
}































export function applyGraphicsClipMaskToPdfImage(image: PdfImage): PdfImage {
  const gs = image.graphicsState;
  const clipMask = gs.clipMask;
  if (!clipMask) {return image;}

  const pixelCount = image.width * image.height;
  if (image.width <= 0 || image.height <= 0 || pixelCount <= 0) {return image;}

  // Map page-space sample points into the clip mask's own mask space.
  // For page-space masks generated by `W/W*`, this is identity, but we keep it explicit.
  const pageToMask = invertMatrix(clipMask.matrix) ?? null;

  const baseAlphaOk = image.alpha && image.alpha.length === pixelCount;
  const newAlpha = new Uint8Array(pixelCount);

  for (let row = 0; row < image.height; row += 1) {
    const v = 1 - (row + 0.5) / image.height; // image space origin is bottom-left
    for (let col = 0; col < image.width; col += 1) {
      const u = (col + 0.5) / image.width;
      const idx = row * image.width + col;

      const base = baseAlphaOk ? (image.alpha![idx] ?? 255) : 255;
      if (base === 0) {
        newAlpha[idx] = 0;
        continue;
      }

      const pagePoint = transformPoint({ x: u, y: v }, gs.ctm);
      const maskPoint = pageToMask ? transformPoint(pagePoint, pageToMask) : pagePoint;
      const m = sampleMaskAlphaInPageSpace(clipMask, maskPoint.x, maskPoint.y);
      newAlpha[idx] = Math.round((base * m) / 255);
    }
  }

  return {
    ...image,
    alpha: newAlpha,
    graphicsState: {
      ...gs,
      clipMask: undefined,
      // `clipBBox` can remain as a conservative culling hint.
    },
  };
}































export function buildPageSpaceSoftMaskForClipMask(gsCtm: PdfMatrix, clipMask: PdfSoftMask): PdfSoftMask | null {
  const ctmInv = invertMatrix(gsCtm);
  if (!ctmInv) {return null;}
  // `softMask` evaluation uses: maskToPage = gs.ctm × softMask.matrix.
  // For a page-space clipMask, we need maskToPage = identity, so softMask.matrix = inv(gs.ctm).
  return {
    ...clipMask,
    kind: "Alpha",
    matrix: ctmInv,
  };
}
