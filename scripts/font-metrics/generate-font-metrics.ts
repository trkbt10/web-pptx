#!/usr/bin/env bun
/**
 * @file Generate font metrics file from measurement data
 *
 * Usage:
 *   bun run scripts/font-metrics/generate-font-metrics.ts <font-name> <latin-average> [options]
 *
 * Example:
 *   bun run scripts/font-metrics/generate-font-metrics.ts calibri 0.56
 *   bun run scripts/font-metrics/generate-font-metrics.ts arial 0.54 --ascender 0.75
 */

import * as fs from "node:fs";
import * as path from "node:path";

const FONTS_DIR = "src/text/fonts";

type FontMetricsConfig = {
  fontName: string;
  latinAverage: number;
  cjkAverage: number;
  ascenderRatio?: number;
  charWidths?: Record<string, number>;
};

function generateFontMetricsFile(config: FontMetricsConfig): string {
  const { fontName, latinAverage, cjkAverage, ascenderRatio, charWidths } = config;
  const constantName = `${fontName.toUpperCase().replace(/[^A-Z0-9]/g, "_")}_METRICS`;
  const displayName = fontName.charAt(0).toUpperCase() + fontName.slice(1);

  let charWidthsCode = "";
  if (charWidths && Object.keys(charWidths).length > 0) {
    const entries = Object.entries(charWidths)
      .map(([char, width]) => {
        const charStr = char === '"' ? '\\"' : char === "\\" ? "\\\\" : char;
        return `    "${charStr}": ${width.toFixed(2)},`;
      })
      .join("\n");
    charWidthsCode = `
    // ${displayName}-specific character widths (measured)
${entries}`;
  }

  const ascenderCode = ascenderRatio !== undefined
    ? `  ascenderRatio: ${ascenderRatio.toFixed(2)},`
    : "";

  return `/**
 * @file ${displayName} font metrics
 *
 * Empirically measured to match LibreOffice rendering.
 *
 * Generated by: scripts/font-metrics/generate-font-metrics.ts
 * Date: ${new Date().toISOString().split("T")[0]}
 */

import type { FontMetrics } from "./types";
import { DEFAULT_CHAR_WIDTHS, SANS_SERIF_KERNING } from "./common";

/**
 * ${displayName} font metrics
 */
export const ${constantName}: FontMetrics = {
  latinAverage: ${latinAverage.toFixed(2)},
  cjkAverage: ${cjkAverage.toFixed(1)},
  charWidths: {
    ...DEFAULT_CHAR_WIDTHS,${charWidthsCode}
  },
  kerning: SANS_SERIF_KERNING,
${ascenderCode}
};
`;
}

function updateFontsIndex(fontName: string): void {
  const indexPath = path.join(FONTS_DIR, "index.ts");
  const content = fs.readFileSync(indexPath, "utf-8");

  const constantName = `${fontName.toUpperCase().replace(/[^A-Z0-9]/g, "_")}_METRICS`;
  const importLine = `import { ${constantName} } from "./${fontName}";`;
  const registryEntry = `  ${fontName}: ${constantName},`;

  // Check if already imported
  if (content.includes(constantName)) {
    console.log(`Font ${fontName} already registered in index.ts`);
    return;
  }

  // Add import after last import from ./
  const importMatch = content.match(/import \{ .+_METRICS \} from "\.\/[^"]+";/g);
  if (importMatch) {
    const lastImport = importMatch[importMatch.length - 1];
    const updated = content.replace(lastImport, `${lastImport}\n${importLine}`);

    // Add to registry
    const registryMatch = updated.match(/const FONT_REGISTRY: Record<string, FontMetrics> = \{([^}]+)\}/);
    if (registryMatch) {
      const registryContent = registryMatch[1];
      const updatedRegistry = registryContent.trimEnd() + `\n${registryEntry}\n`;
      const finalContent = updated.replace(registryMatch[1], updatedRegistry);
      fs.writeFileSync(indexPath, finalContent);
      console.log(`Updated ${indexPath} with ${fontName} metrics`);
    }
  }
}

// Parse arguments
const args = process.argv.slice(2);

if (args.length < 2 || args[0] === "--help") {
  console.log("Usage:");
  console.log("  bun run scripts/font-metrics/generate-font-metrics.ts <font-name> <latin-average> [options]");
  console.log("");
  console.log("Options:");
  console.log("  --ascender <ratio>    Ascender ratio (default: none)");
  console.log("  --cjk <average>       CJK average width (default: 1.0)");
  console.log("  --dry-run             Print generated code without writing");
  console.log("");
  console.log("Example:");
  console.log("  bun run scripts/font-metrics/generate-font-metrics.ts calibri 0.56 --ascender 0.75");
  process.exit(0);
}

const fontName = args[0].toLowerCase();
const latinAverage = parseFloat(args[1]);

if (isNaN(latinAverage) || latinAverage <= 0 || latinAverage > 2) {
  console.error(`Invalid latinAverage: ${args[1]}`);
  process.exit(1);
}

// Parse options
let cjkAverage = 1.0;
let ascenderRatio: number | undefined;
let dryRun = false;

for (let i = 2; i < args.length; i++) {
  if (args[i] === "--ascender" && args[i + 1]) {
    ascenderRatio = parseFloat(args[i + 1]);
    i++;
  } else if (args[i] === "--cjk" && args[i + 1]) {
    cjkAverage = parseFloat(args[i + 1]);
    i++;
  } else if (args[i] === "--dry-run") {
    dryRun = true;
  }
}

const config: FontMetricsConfig = {
  fontName,
  latinAverage,
  cjkAverage,
  ascenderRatio,
};

const content = generateFontMetricsFile(config);

if (dryRun) {
  console.log("=== Generated content (dry run) ===");
  console.log(content);
} else {
  const filePath = path.join(FONTS_DIR, `${fontName}.ts`);

  if (fs.existsSync(filePath)) {
    console.log(`File already exists: ${filePath}`);
    console.log("Use --dry-run to preview changes or manually edit the file.");
    process.exit(1);
  }

  fs.writeFileSync(filePath, content);
  console.log(`Created: ${filePath}`);

  // Update index
  updateFontsIndex(fontName);
}
