/**
 * @file XLS fixtures integration checks
 *
 * Uses `spec/xls-fixtures/*.xls` generated by `bun run scripts/generate-xls-fixtures/index.ts`.
 */

import { readFile } from "node:fs/promises";
import path from "node:path";
import { parseXls } from "@oxen-office/xls";
import { exportXlsx } from "@oxen-office/xlsx/exporter";
import { parseXlsxWorkbook } from "@oxen-office/xlsx/parser";
import { loadZipPackage } from "@oxen/zip";

function fixturePath(name: string): string {
  return path.join(process.cwd(), "spec", "xls-fixtures", name);
}

async function parseXlsFixture(name: string) {
  const bytes = await readFile(fixturePath(name));
  return parseXls(new Uint8Array(bytes));
}

describe("XLS fixtures (parseXls + exportXlsx)", () => {
  it("minimal.xls: parses a single sheet with a shared string", async () => {
    const wb = await parseXlsFixture("minimal.xls");
    expect(wb.sheets).toHaveLength(1);
    expect(wb.sheets[0]?.name).toBe("Sheet1");
    expect(wb.sheets[0]?.state).toBe("visible");
    expect(wb.sheets[0]?.rows[0]?.cells[0]?.value).toEqual({ type: "string", value: "Hello" });

    const xlsxBytes = await exportXlsx(wb);
    const pkg = await loadZipPackage(xlsxBytes);
    const sheetXml = pkg.readText("xl/worksheets/sheet1.xml");
    if (!sheetXml) {
      throw new Error("sheet1.xml must exist");
    }
    expect(sheetXml).toContain("<v>0</v>");

    const parsed = await parseXlsxWorkbook((p) => {
      return Promise.resolve(pkg.readText(p) ?? undefined);
    });
    expect(parsed.sheets[0]?.rows[0]?.cells[0]?.value).toEqual({ type: "string", value: "Hello" });
  });

  it("all-features.xls: parses styles, merges, sheetFormatPr, and a numeric formula", async () => {
    const wb = await parseXlsFixture("all-features.xls");

    expect(wb.sheets.map((s) => ({ name: s.name, state: s.state }))).toEqual([
      { name: "Sheet1", state: "visible" },
      { name: "Hidden", state: "veryHidden" },
    ]);

    const sheet1 = wb.sheets[0];
    if (!sheet1) {
      throw new Error("Sheet1 must exist");
    }
    expect(sheet1.sheetFormatPr).toEqual({ defaultRowHeight: 15, defaultColWidth: 12, zeroHeight: false });

    expect(sheet1.mergeCells).toEqual([
      {
        start: { row: 1, col: 1, rowAbsolute: false, colAbsolute: false },
        end: { row: 2, col: 1, rowAbsolute: false, colAbsolute: false },
      },
    ]);

    const row1 = sheet1.rows.find((r) => (r.rowNumber as number) === 1);
    if (!row1) {
      throw new Error("Row 1 must exist");
    }
    const cellE1 = row1.cells.find((c) => (c.address.col as number) === 5);
    if (!cellE1) {
      throw new Error("E1 must exist");
    }
    expect(cellE1.value).toEqual({ type: "number", value: 11 });
    expect(cellE1.formula).toEqual({ type: "normal", expression: "5+6" });

    const xlsxBytes = await exportXlsx(wb);
    const pkg = await loadZipPackage(xlsxBytes);
    const sheetXml = pkg.readText("xl/worksheets/sheet1.xml");
    if (!sheetXml) {
      throw new Error("sheet1.xml must exist");
    }
    expect(sheetXml).toContain("<sheetFormatPr");
    expect(sheetXml).toContain("<mergeCells");
    expect(sheetXml).toContain("<f>5+6</f>");

    const parsed = await parseXlsxWorkbook((p) => {
      return Promise.resolve(pkg.readText(p) ?? undefined);
    });
    const parsedRow1 = parsed.sheets[0]?.rows.find((r) => (r.rowNumber as number) === 1);
    const parsedE1 = parsedRow1?.cells.find((c) => (c.address.col as number) === 5);
    expect(parsedE1?.formula).toEqual({ type: "normal", expression: "5+6" });
    expect(parsedE1?.value).toEqual({ type: "number", value: 11 });
  });
});
